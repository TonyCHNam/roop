# post_processing.py
import cv2
import numpy as np
from realesrgan import RealESRGAN  # pip install realesrgan
import os

def enhance_video(input_video: str, output_video: str, scale: int = 2, device: str = 'cuda') -> None:
    """
    Real-ESRGAN을 사용하여 input_video를 super-resolution 처리한 후 output_video로 저장합니다.
    
    :param input_video: 원본 영상 파일 경로
    :param output_video: 후처리된 영상 파일 경로
    :param scale: 업스케일 배율 (일반적으로 2 또는 4)
    :param device: 사용할 디바이스 ('cuda' 또는 'cpu')
    """
    # RealESRGAN 모델 초기화 (scale에 따라 모델 파일이 달라집니다)
    model = RealESRGAN(device, scale=scale)
    
    # 모델 가중치 다운로드 및 로드 (가중치 파일이 없으면 자동 다운로드합니다)
    # 여기서는 x2 모델 예시. 다른 배율은 해당 모델 파일 이름을 사용하세요.
    model_path = f'RealESRGAN_x{scale}.pth'
    if not os.path.exists(model_path):
        # 모델 파일이 없으면 자동 다운로드 (실제 프로젝트에 맞게 다운로드 코드를 추가할 수 있음)
        print(f"{model_path} not found. Please download the model file manually.")
        return
    model.load_weights(model_path)

    cap = cv2.VideoCapture(input_video)
    if not cap.isOpened():
        print("Error: Unable to open input video.")
        return

    fps = cap.get(cv2.CAP_PROP_FPS)
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) * scale
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) * scale

    # 호환성을 위해 mp4 컨테이너와 적절한 코덱 사용 (예: 'mp4v')
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(output_video, fourcc, fps, (width, height))

    frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    print(f"Total frames: {frame_count}")
    
    frame_idx = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # Real-ESRGAN으로 프레임 업스케일 (cv2에서 BGR 형식)
        sr_frame = model.predict(frame)  # 모델에 따라 predict 함수 사용
        out.write(sr_frame)
        frame_idx += 1
        if frame_idx % 10 == 0:
            print(f"Processed {frame_idx}/{frame_count} frames")
    
    cap.release()
    out.release()
    print("Super resolution processing completed!")
